<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    />
    <title>Comandos de Linux para Expertos - Nivel 4</title>
    <link
        rel="stylesheet"
        href="../../../../css/styles.css"
    />
</head>
<body>
    <header>
        <h1>Comandos de Linux para Expertos</h1>
        <nav class="breadcrumb">
            <a href="../../../../index.html"><i class="fas fa-home"></i> Inicio</a>
            /
            <a href="../index.html">EdiII</a>
            /
            <a href="index.html">Comandos Linux</a>
            / Nivel Experto
        </nav>
    </header>

    <main>
        <div class="note">
            <p>
                <i class="fas fa-exclamation-circle"></i> Esta secci√≥n profundiza en comandos, t√©cnicas y herramientas de
                nivel experto en Linux. Estos conceptos avanzados te permitir√°n
                dominar por completo el sistema operativo, automatizar tareas
                complejas y resolver problemas a nivel profesional. Prep√°rate para llevar tus habilidades de Linux al siguiente nivel.
            </p>
        </div>

        <section>
            <h2><i class="fas fa-code"></i> Scripting Avanzado en Bash</h2>

            <div class="concept-box">
                <h3><i class="fas fa-robot"></i> El poder de la automatizaci√≥n con scripts</h3>
                <p>
                    El shell scripting es el coraz√≥n de la automatizaci√≥n en Linux. A trav√©s de scripts de Bash
                    puedes orquestar la ejecuci√≥n de m√∫ltiples comandos, implementar l√≥gica condicional sofisticada y
                    automatizar tareas repetitivas, transformando procesos manuales en flujos de trabajo eficientes y aut√≥nomos.
                </p>

                <p>
                    En este nivel experto, se espera que un usuario de Linux pueda desarrollar
                    scripts robustos que no solo ejecuten tareas, sino que tambi√©n gestionen errores de forma elegante,
                    procesen datos de diversas fuentes de manera inteligente y se adapten a diferentes escenarios sin intervenci√≥n.
                </p>
            </div>

            <div class="tech-container">
                <div class="tech-box">
                    <div class="tech-title"><i class="fas fa-cogs"></i> Estructuras de control avanzadas</div>
                    <div class="tech-image">üîÑ</div>
                    <p>
                        Las estructuras de control en Bash son fundamentales para dotar a tus scripts de inteligencia y adaptabilidad,
                        permitiendo la toma de decisiones complejas y la ejecuci√≥n selectiva de bloques de c√≥digo.
                    </p>

                    <div class="why-learn">
                        <strong><i class="fas fa-question-circle"></i> ¬øPor qu√© deber√≠as conocerlas?</strong>
                        <p>
                            Dominar las estructuras avanzadas de control te capacita para construir scripts
                            resilientes que pueden anticipar y manejar condiciones inesperadas, manipular datos de forma inteligente
                            y bifurcar la ejecuci√≥n bas√°ndose en m√∫ltiples criterios. Sin estas herramientas, tus scripts ser√≠an
                            secuenciales y vulnerables a fallos ante la diversidad de situaciones que pueden surgir en un entorno real.
                        </p>
                    </div>

                    <div class="script-box">
                        <span class="comment">#!/bin/bash</span>
                        <span class="comment"># Ejemplo de estructura case</span>
                        <span class="prompt">read</span> <span class="prompt">-p</span> "Ingrese un comando (backup/status/update): " comando
                        <span class="prompt">case</span> "<span class="output">$comando</span>" <span class="prompt">in</span>
                        <span class="output">  backup)</span>
                        <span class="output">    echo "Iniciando backup..."</span>
                        <span class="output">    </span><span class="comment"># C√≥digo para el backup</span>
                        <span class="output">    ;;</span>
                        <span class="output">  status)</span>
                        <span class="output">    echo "Verificando estado del sistema..."</span>
                        <span class="prompt">    if</span> <span class="prompt">systemctl</span> is-active --quiet apache2; <span class="prompt">then</span>
                        <span class="output">      echo "El servidor web est√° activo"</span>
                        <span class="prompt">    else</span>
                        <span class="output">      echo "El servidor web est√° inactivo"</span>
                        <span class="prompt">    fi</span>
                        <span class="output">    ;;</span>
                        <span class="output">  update)</span>
                        <span class="output">    echo "Actualizando el sistema..."</span>
                        <span class="output">    </span><span class="comment"># C√≥digo para actualizaci√≥n</span>
                        <span class="output">    ;;</span>
                        <span class="output">  *)</span>
                        <span class="output">    echo "Comando no reconocido: </span><span class="output">$comando</span><span class="output>"</span>
                        <span class="prompt">    exit</span> 1
                        <span class="output">    ;;</span>
                        <span class="prompt">esac</span>

                        <span class="comment"># Ejemplo de bucle for con m√∫ltiples fuentes</span>
                        <span class="prompt">echo</span> "Verificando espacio en discos:"
                        <span class="prompt">for</span> disco <span class="prompt">in</span> /dev/sd{a,b,c}; <span class="prompt">do</span>
                        <span class="prompt">  if</span> <span class="prompt">[</span> <span class="prompt">-e</span> "<span class="output">$disco</span>" <span class="prompt">]</span>; <span class="prompt">then</span>
                        <span class="output">    </span><span class="prompt">echo</span> <span class="prompt">-n</span> "<span class="output">$disco</span>: "
                        <span class="output">    </span><span class="prompt">df</span> <span class="prompt">-h</span> "<span class="output">$disco</span>" 2>/dev/null | <span class="prompt">grep</span> <span class="prompt">-v</span> Filesystem || <span class="prompt">echo</span> "No montado"
                        <span class="prompt">  fi</span>
                        <span class="prompt">done</span>

                        <span class="comment"># Ejemplo de bucle while con lectura de archivo</span>
                        <span class="prompt">echo</span> "Procesando usuarios:"
                        <span class="prompt">while</span> IFS=: <span class="prompt">read</span> <span class="prompt">-r</span> usuario _ uid gid _ home shell; <span class="prompt">do</span>
                        <span class="prompt">  if</span> <span class="prompt">[</span> "<span class="output">$uid</span>" <span class="prompt">-ge</span> 1000 <span class="prompt">]</span> && <span class="prompt">[</span> "<span class="output">$uid</span>" <span class="prompt">-lt</span> 60000 <span class="prompt">]</span>; <span class="prompt">then</span>
                        <span class="output">    </span><span class="prompt">echo</span> "Usuario: <span class="output">$usuario</span>, UID: <span class="output">$uid</span>, Home: <span class="output">$home</span>, Shell: <span class="output">$shell</span>"
                        <span class="prompt">  fi</span>
                        <span class="prompt">done</span> < /etc/passwd
                    </div>

                    <p><strong>Estructuras de control en Bash:</strong></p>
                    <ul>
                        <li><code>if/elif/else</code>: Evaluaci√≥n condicional de bloques de c√≥digo.</li>
                        <li><code>case</code>: Selecci√≥n de una acci√≥n basada en el valor de una variable.</li>
                        <li><code>for</code>: Iteraci√≥n a trav√©s de una lista de elementos o un rango num√©rico.</li>
                        <li><code>while</code>: Ejecuci√≥n repetida de un bloque de c√≥digo mientras una condici√≥n sea verdadera.</li>
                        <li><code>until</code>: Ejecuci√≥n repetida de un bloque de c√≥digo hasta que una condici√≥n sea verdadera.</li>
                        <li><code>select</code>: Creaci√≥n de men√∫s interactivos para la selecci√≥n de opciones.</li>
                        <li>Expansiones: <code>{a,b,c}</code> (generaci√≥n de combinaciones), <code>{1..10}</code> (generaci√≥n de secuencias num√©ricas).</li>
                    </ul>

                    <div class="exercise-box">
                        <strong><i class="fas fa-pencil-alt"></i> Ejercicios para practicar:</strong>
                        <ol>
                            <li>Crea un script que tome un directorio como argumento y muestre los 5 archivos m√°s grandes dentro de √©l, ordenados por tama√±o.</li>
                            <li>Escribe un script que lea un archivo CSV l√≠nea por l√≠nea y, bas√°ndose en el valor de la primera columna, ejecute una acci√≥n espec√≠fica definida en el script.</li>
                            <li>Implementa un men√∫ interactivo utilizando la estructura <code>select</code> que ofrezca al usuario varias opciones para ejecutar diferentes comandos del sistema (por ejemplo, mostrar la memoria libre, listar los procesos en ejecuci√≥n, etc.).</li>
                            <li>Desarrolla un script que itere sobre todos los usuarios del sistema definidos en <code>/etc/passwd</code> y verifique si su directorio de inicio existe y tiene los permisos de lectura, escritura y ejecuci√≥n correctos para el propietario.</li>
                        </ol>
                    </div>
                </div>

                <div class="tech-box">
                    <div class="tech-title"><i class="fas fa-puzzle-piece"></i> Funciones y modularizaci√≥n</div>
                    <div class="tech-image">üß©</div>
                    <p>
                        Las funciones en Bash permiten encapsular bloques de c√≥digo para su reutilizaci√≥n, promoviendo la organizaci√≥n y el mantenimiento eficiente de scripts complejos.
                    </p>

                    <div class="why-learn">
                        <strong><i class="fas fa-question-circle"></i> ¬øPor qu√© deber√≠as conocerlas?</strong>
                        <p>
                            Al igual que en otros lenguajes de programaci√≥n, las funciones son esenciales para escribir c√≥digo limpio,
                            reutilizable y f√°cil de mantener. Permiten descomponer problemas complejos en m√≥dulos m√°s peque√±os y manejables,
                            evitando la redundancia de c√≥digo y simplificando la depuraci√≥n y futuras modificaciones de tus scripts.
                        </p>
                    </div>

                    <div class="script-box">
                        <span class="comment">#!/bin/bash</span>

                        <span class="comment"># Definici√≥n de funciones con par√°metros y valor de retorno</span>
                        <span class="prompt">verificar_espacio</span>() {
                        <span class="output">  local directorio="</span><span class="output"><span class="math-inline">1</span\><span class\="output\>"</span\>
<span class\="output"\>  local minimo\="</span\><span class\="output"\></span>{2:-100}</span><span class="output>" </span><span class="comment"># Valor por defecto: 100MB</span>
                        <span class="comment">  # Obtener espacio libre en MB</span>
                        <span class="output">  local espacio_libre=$(</span><span class="prompt">df</span> <span class="prompt">-m</span> "<span class="output">$directorio</span>" | <span class="prompt">awk</span> 'NR==2 {print $4}')
                        <span class="prompt">  if</span> <span class="prompt">[</span> "<span class="output">$espacio_libre</span>" <span class="prompt">-lt</span> "<span class="output">$minimo</span>" <span class="prompt">]</span>; <span class="prompt">then</span>
                        <span class="output">    </span><span class="prompt">echo</span> "ADVERTENCIA: Queda poco espacio en <span class="output">$directorio</span> (<span class="output">$espacio_libre</span> MB)"
                        <span class="prompt">    return</span> 1
                        <span class="prompt">  else</span>
                        <span class="output">    </span><span class="prompt">echo</span> "Espacio suficiente en <span class="output">$directorio</span> (<span class="output">$espacio_libre</span> MB)"
                        <span class="prompt">    return</span> 0
                        <span class="prompt">  fi</span>
                        }

                        <span class="comment"># Funci√≥n para log con timestamp</span>
                        <span class="prompt">log</span>() {
                        <span class="output">  local nivel="</span><span class="output">$1</span><span class="output>"</span>
                        <span class="output">  local mensaje="</span><span class="output"><span class="math-inline">2</span\><span class\="output\>"</span\>
<span class\="output"\>  local timestamp\=</span>(</span><span class="prompt">date</span> '+%Y-%m-%d %H:%M:%S')
                        <span class="prompt">  echo</span> "[<span class="output">$timestamp</span>] [<span class="output">$nivel</span>] <span class="output">$mensaje</span>" >> "/var/log/miscript.log"
                        <span class="comment">  # Si es error, tambi√©n mostrar en stderr</span>
                        <span class="prompt">  if</span> <span class="prompt">[</span> "<span class="output">$nivel</span>" = "ERROR" <span class="prompt">]</span>; <span class="prompt">then</span>
                        <span class="output">    </span><span class="prompt">echo</span> "[<span class="output">$timestamp</span>] [<span class="output">$nivel</span>] <span class="output">$mensaje</span>" >&2
                        <span classprompt">  fi</span>
                        }

                        <span class="comment"># Funci√≥n para limpieza antes de salir</span>
                        <span class="prompt">limpiar</span>() {
                        <span class="output">  </span><span class="prompt">echo</span> "Realizando limpieza..."
                        <span class="prompt">  </span><span class="prompt">[</span> <span class="prompt">-f</span> "<span class="output">$TEMP_FILE</span>" <span class="prompt">]</span> && <span class="prompt">rm</span> "<span class="output">$TEMP_FILE</span>"
                        <span class="prompt">  log</span> "INFO" "Script finalizado, recursos liberados"
                        }

                        <span class="comment"># Registrar funci√≥n de limpieza para que se ejecute al salir</span>
                        <span class="prompt">trap</span> limpiar EXIT

                        <span class="comment"># Uso de las funciones</span>
                        <span class="prompt">TEMP_FILE</span>=$(<span class="prompt">mktemp</span>)
                        <span class="prompt">log</span> "INFO" "Script iniciado con PID <span class="output">$$</span>"

                        <span class="prompt">verificar_espacio</span> "/home" 500
                        <span class="prompt">if</span> <span class="prompt">[</span> <span class="output">$?</span> <span class="prompt">-eq</span> 0 <span class="prompt">]</span>; <span class="prompt">then</span>
                        <span class="output">  </span><span class="prompt">echo</span> "Procediendo con la operaci√≥n..."
                        <span class="output">  </span><span class="prompt">log</span> "INFO" "Verificaci√≥n de espacio exitosa"
                        <span class="prompt">else</span>
                        <span class="output">  </span><span class="prompt">log</span> "ERROR" "Espacio insuficiente para continuar"
                        <span class="prompt">  exit</span> 1
                        <span class="prompt">fi</span>
                    </div>

                    <p><strong>Caracter√≠sticas avanzadas de funciones:</strong></p>
                    <ul>
                        <li>Variables locales con <code>local</code> para limitar su alcance dentro de la funci√≥n.</li>
                        <li>Par√°metros posicionales (<code>$1</code>, <code>$2</code>, ...) para acceder a los argumentos pasados a la funci√≥n.</li>
                        <li>Definici√≥n de par√°metros con valores por defecto utilizando <code>${parametro:-valor_por_defecto}</code>.</li>
                        <li>Retorno de valores utilizando el comando <code>return</code>, cuyo estado de salida puede ser capturado con <code>$?</code>.</li>
                        <li>Captura de la salida de una funci√≥n utilizando la sustituci√≥n de comandos: <code>$(funcion argumentos)</code>.</li>
                        <li>Uso de <code>trap</code> para definir acciones a ejecutar ante ciertas se√±ales o al salir del script, ideal para tareas de limpieza.</li>
                    </ul>

                    <div class="exercise-box">
                        <strong><i class="fas fa-pencil-alt"></i> Ejercicios para practicar:</strong>
                        <ol>
                            <li>Crea un script que incluya funciones para realizar tareas comunes de administraci√≥n del sistema, como verificar el espacio libre en disco, listar los procesos en ejecuci√≥n y mostrar la carga promedio del sistema. El script principal debe llamar a estas funciones seg√∫n la opci√≥n que elija el usuario.</li>
                            <li>Implementa un sistema de registro (logging) dentro de un script utilizando funciones. Debes tener funciones separadas para registrar mensajes de nivel INFO, WARNING y ERROR, y cada mensaje debe incluir una marca de tiempo.</li>
                            <li>Escribe una funci√≥n de validaci√≥n que tome un par√°metro (por ejemplo, una direcci√≥n de correo electr√≥nico o un n√∫mero de tel√©fono) y devuelva un c√≥digo de estado (0 para v√°lido, 1 para inv√°lido) despu√©s de realizar una verificaci√≥n b√°sica de formato.</li>
                            <li>Desarrolla una "biblioteca" de funciones reutilizables en un archivo separado (por ejemplo, <code>funciones_utiles.sh</code>) y crea un script principal que importe y utilice estas funciones mediante el comando <code>source</code>.</li>
                        </ol>
                    </div>
                </div>

                <div class="tech-box">
                    <div class="tech-title"><i class="fas fa-bug"></i> Depuraci√≥n y Manejo de Errores</div>
                    <div class="tech-image">üêõ</div>
                    <p>
                        Un script robusto no solo realiza su tarea, sino que tambi√©n anticipa y maneja errores de manera controlada, proporcionando informaci√≥n √∫til para la depuraci√≥n.
                    </p>

                    <div class="script-box">
                        <span class="comment">#!/bin/bash</span>

                        <span class="comment"># Habilitar modo de depuraci√≥n para ver cada comando ejecutado</span>
                        <span class="prompt">set</span> <span class="prompt">-x</span>

                        <span class="comment"># Asegurarse de que el script termine si un comando falla</span>
                        <span class="prompt">set</span> <span class="prompt">-e</span>

                        <span class="comment"># Asegurarse de que los errores en las tuber√≠as tambi√©n causen la salida</span>
                        <span class="prompt">set</span> <span class="prompt">-o</span> pipefail

                        <span class="comment"># Funci√≥n para manejar errores</span>
                        <span class="prompt">manejar_error</span>() {
                        <span class="output">  </span><span class="prompt">echo</span> "ERROR en l√≠nea <span class="output">$1</span> ejecutando: <span class="output">$2</span>" >&2
                        <span class="prompt">  exit</span> 1
                        }

                        <span class="comment"># Capturar errores y llamar a la funci√≥n manejar_error</span>
                        <span class="prompt">trap</span> 'manejar_error <span class="output">$LINENO</span> "<span class="output">$BASH_COMMAND</span>"' ERR

                        <span class="comment"># Ejemplo de validaci√≥n de par√°metros</span>
                        <span class="prompt">if</span> <span class="prompt">[</span> <span class="output">$#</span> <span class="prompt">-lt</span> 1 <span class="prompt">]</span>; <span class="prompt">then</span>
                        <span class="output">  </span><span class="prompt">echo</span> "Uso: <span class="output">$0</span> archivo" >&2
                        <span class="prompt">  exit</span> 1
                        <span class="prompt">fi</span>

                        <span class="prompt">archivo</span>="<span class="output">$1</span>"
                        <span class="prompt">cat</span> "<span class="output">$archivo</span>" <span class="comment"># Este comando fallar√° si el archivo no existe, y el trap se activar√°</span>
                    </div>

                    <p><strong>T√©cnicas de depuraci√≥n y manejo de errores:</strong></p>
                    <ul>
                        <li><code>set -x</code>: Activa el modo de depuraci√≥n, mostrando cada comando antes de su ejecuci√≥n.</li>
                        <li><code>set -e</code>: Hace que el script termine inmediatamente si un comando falla (devuelve un c√≥digo de salida diferente de cero).</li>
                        <li><code>set -o pipefail</code>: En una tuber√≠a de comandos, hace que el script termine si cualquier comando en la tuber√≠a falla.</li>
                        <li><code>trap</code>: Permite especificar comandos para ser ejecutados al recibir ciertas se√±ales (como errores, salida del script, etc.). <code>trap 'comando' SE√ëAL</code>. La se√±al <code>ERR</code> se activa cuando un comando devuelve un c√≥digo de salida no cero.</li>
                        <li>Validaci√≥n exhaustiva de las entradas del usuario y los par√°metros del script para prevenir comportamientos inesperados o vulnerabilidades de seguridad.</li>
                    </ul>

                    <div class="exercise-box">
                        <strong><i class="fas fa-pencil-alt"></i> Ejercicios para practicar:</strong>
                        <ol>
                            <li>Crea un script que intente realizar una operaci√≥n que podr√≠a fallar (por ejemplo, eliminar un archivo que quiz√°s no exista). Utiliza <code>set -e</code> y observa el comportamiento del script cuando la operaci√≥n falla. Modifica el script para usar <code>trap</code> y capturar el error, mostrando un mensaje informativo en lugar de terminar abruptamente.</li>
                            <li>Escribe un script que tome un n√∫mero como entrada del usuario. Implementa una validaci√≥n para asegurar que la entrada sea realmente un n√∫mero. Si no lo es, muestra un mensaje de error y termina el script.</li>
                            <li>Desarrolla un script que ejecute una serie de comandos en una tuber√≠a. Utiliza <code>set -o pipefail</code> y simula un fallo en uno de los comandos de la tuber√≠a para observar c√≥mo afecta la ejecuci√≥n del script.</li>
                            <li>Implementa una funci√≥n en un script que realice una tarea y devuelva un c√≥digo de salida espec√≠fico para indicar √©xito o diferentes tipos de errores. En el script principal, llama a esta funci√≥n y utiliza el c√≥digo de salida (<code>$?</code>) para decidir qu√© acci√≥n tomar a continuaci√≥n.</li>
                        </ol>
                    </div>
                </div>

                <div class="tech-box">
                    <div class="tech-title"><i class="fas fa-search"></i> Evaluaci√≥n de comandos y expansiones</div>
                    <div class="tech-image">üîç</div>
                    <p>
                        Bash ofrece potentes mecanismos para manipular strings, evaluar expresiones aritm√©ticas y expandir variables de formas avanzadas, permitiendo una sintaxis concisa y poderosa.
                    </p>

                    <div class="why-learn">
                        <strong><i class="fas fa-question-circle"></i> ¬øPor qu√© deber√≠as conocerlas?</strong>
                        <p>
                            Dominar las t√©cnicas avanzadas de expansi√≥n y evaluaci√≥n te permite escribir scripts m√°s eficientes y legibles,
                            realizar operaciones complejas sobre datos de texto y variables directamente en la shell, y adaptar el comportamiento
                            de tus scripts de manera din√°mica basada en el entorno o las entradas.
                        </p>
                    </div>

                    <div class="script-box">
                        <span class="comment">#!/bin/bash</span>

                        <span class="comment"># Ejemplo de manipulaci√≥n avanzada de strings</span>
                        <span class="prompt">archivo</span>="documento.principal.txt.backup"
                        <span class="prompt">echo</span> "Nombre base: <span class="output">${archivo%.*}</span>" <span class="comment"># documento.principal.txt</span>
                        <span class="prompt">echo</span> "Extensi√≥n: <span class="output">${archivo##*.}</span>" <span class="comment"># backup</span>
                        <span class="prompt">echo</span> "Sin prefijo: <span class="output">${archivo#documento.}</span>" <span class="comment"># principal.txt.backup</span>
                        <span class="prompt">echo</span> "Reemplazo: <span class="output">${archivo/principal/secundario}</span>" <span class="comment"># documento.secundario.txt.backup</span>

                        <span class="comment"># Expansi√≥n de variables con valores por defecto</span>
                        <span class="prompt">directorio</span>="<span class="output">${1:-$(pwd)}</span>" <span class="comment"># Usa el primer par√°metro o el directorio actual</span>
                        <span class="prompt">usuario</span>="<span class="output">${SUDO_USER:-$USER}</span>" <span class="comment"># Usa SUDO_USER si existe, o USER si no</span>
                        <span class="prompt">memoria</span>="<span class="output">${RAM_MINIMA:=512}</span>" <span class="comment"># Asigna 512 si RAM_MINIMA no est√° definida</span>

                        <span class="comment"># Sustituci√≥n de comandos</span>
                        <span class="prompt">usuarios</span>=$(<span class="prompt">cut</span> <span class="prompt">-d:</span> <span class="prompt">-f1</span> /etc/passwd | <span class="prompt">sort</span>)
                        <span class="prompt">echo</span> "Primer usuario: $(<span class="prompt">echo</span> "<span class="output">$usuarios</span>" | <span class="prompt">head</span> <span class="prompt">-1</span>)"

                        <span class="comment"># Evaluaci√≥n aritm√©tica</span>
                        <span class="prompt">num1</span>=10
                        <span class="prompt">num2</span>=5
                        <span class="prompt">echo</span> "Suma: $((num1 + num2))"
                        <span class="prompt">echo</span> "Producto: $((num1 * num2))"
                    </div>

                    <p><strong>T√©cnicas avanzadas de expansi√≥n:</strong></p>
                    <ul>
                        <li>Sustituci√≥n de comandos: <code>$(comando)</code> o <code>`comando`</code> ejecuta el comando y reemplaza la salida en la l√≠nea.</li>
                        <li>Evaluaci√≥n aritm√©tica: <code>$((expresi√≥n))</code> realiza operaciones aritm√©ticas.</li>
                        <li>Expansi√≥n de llaves: <code>{inicio..fin}</code> para generar secuencias, <code>{op1,op2,op3}</code> para generar combinaciones.</li>
                        <li>Manipulaci√≥n de strings:
                            <ul>
                                <li><code>${var#patr√≥n}</code>: Elimina el prefijo m√°s corto que coincide con el patr√≥n.</li>
                                <li><code>${var##patr√≥n}</code>: Elimina el prefijo m√°s largo que coincide con el patr√≥n.</li>
                                <li><code>${var%patr√≥n}</code>: Elimina el sufijo m√°s corto que coincide con el patr√≥n.</li>
                                <li><code>${var%%patr√≥n}</code>: Elimina el sufijo m√°s largo que coincide con el patr√≥n.</li>
                                <li><code>${var/patr√≥n/reemplazo}</code>: Reemplaza la primera coincidencia del patr√≥n.</li>
                                <li><code>${var//patr√≥n/reemplazo}</code>: Reemplaza todas las coincidencias del patr√≥n.</li>
                            </ul>
                        </li>
                        <li>Valores por defecto de variables:
                            <ul>
                                <li><code>${var:-valor}</code>: Usa <code>valor</code> si <code>var</code> no est√° definida o est√° vac√≠a.</li>
                                <li><code>${var:=valor}</code>: Asigna <code>valor</code> a <code>var</code> si no est√° definida o vac√≠a, y luego usa <code>valor</code>.</li>
                                <li><code>${var:?mensaje}</code>: Muestra un error con <code>mensaje</code> y sale si <code>var</code> no est√° definida o vac√≠a.</li>
                                <li><code>${var:+valor}</code>: Usa <code>valor</code> si <code>var</code> est√° definida y no est√° vac√≠a, sino usa nada.</li>
                            </ul>
                        </li>
                        <li>Indirecci√≥n de variables: <code>${!nombre_de_variable}</code> usa el valor de <code>nombre_de_variable</code> como el nombre de otra variable cuyo valor se recupera.</li>
                        <li>Expansi√≥n de substrings: <code>${var:posici√≥n:longitud}</code> extrae una subcadena.</li>
                    </ul>

                    <div class="exercise-box">
                        <strong><i class="fas fa-pencil-alt"></i> Ejercicios para practicar:</strong>
                        <ol>
                            <li>Crea un script que utilice la expansi√≥n de llaves para generar una serie de directorios con nombres como <code>backup-01</code>, <code>backup-02</code>, ..., <code>backup-10</code>.</li>
                            <li>Escribe un script que tome un nombre de archivo como entrada y utilice la manipulaci√≥n de strings para extraer el nombre base (sin extensi√≥n) y la extensi√≥n del archivo.</li>
                            <li>Implementa un sistema de configuraci√≥n simple en un script donde las variables de configuraci√≥n pueden ser definidas por el usuario a trav√©s de variables de entorno. Utiliza los valores por defecto de las variables Bash para asegurar que el script tenga valores predeterminados si las variables de entorno no est√°n definidas.</li>
                            <li>Desarrolla un script que utilice la indirecci√≥n de variables para acceder a un conjunto de variables cuyos nombres est√°n almacenados en otra variable. Por ejemplo, si tienes una variable <code>var_name="user_list"</code> y otra variable <code>user_list="alice,bob,charlie"</code>, usa la indirecci√≥n para acceder al valor de <code>user_list</code>.</li>
                        </ol>
                    </div>
                </div>

                <div class="tech-box">
                    <div class="tech-title"><i class="fas fa-shield-alt"></i> Seguridad en Scripts Bash</div>
                    <div class="tech-image">üîí</div>
                    <p>
                        La seguridad es primordial al escribir scripts, especialmente aquellos que interact√∫an con el sistema o manejan datos sensibles. Es crucial protegerse contra inyecciones de comandos y otras vulnerabilidades.
                    </p>

                    <div class="script-box">
                        <span class="comment">#!/bin/bash</span>

                        <span class="comment"># Validaci√≥n de entradas para evitar inyecci√≥n de comandos</span>
                        <span class="prompt">read</span> <span class="prompt">-p</span> "Ingrese un nombre de archivo: " archivo
                        <span class="prompt">if</span> [[ "<span class="output">$archivo</span>" =~ ^[a-zA-Z0-9._-]+$ ]]; <span class="prompt">then</span>
                        <span class="output">  </span><span class="prompt">echo</span> "Procesando archivo: <span class="output">$archivo</span>"
                        <span class="comment">  # Seguro para usar en comandos</span>
                        <span class="prompt">  cat</span> "<span class="output">$archivo</span>"
                        <span class="prompt">else</span>
                        <span class="output">  </span><span class="prompt">echo</span> "ERROR: Nombre de archivo inv√°lido." >&2
                        <span class="prompt">  exit</span> 1
                        <span class="prompt">fi</span>

                        <span class="comment"># Usar rutas absolutas para comandos cr√≠ticos</span>
                        <span class="prompt">/bin/rm</span> -f "/tmp/archivo_temporal"

                        <span class="comment"># Evitar el uso de eval</span>
                        <span class="comment"># peligroso: eval "comando_$opcion"</span>

                        <span class="comment"># Usar IFS para prevenir la divisi√≥n de palabras no intencionada</span>
                        <span class="prompt">IFS</span>=$'\n'
                        <span class="prompt">for</span> linea <span class="prompt">in</span> $(<span class="prompt">cat</span> "archivo_con_espacios.txt"); <span class="prompt">do</span>
                        <span class="output">  </span><span class="comment"># Procesar cada l√≠nea de forma segura</span>
                        <span class="output">  </span><span class="prompt">echo</span> "L√≠nea: <span class="output">$linea</span>"
                        <span class="prompt">done</span>

                        <span class="comment"># Usar printf para formatear la salida de forma segura</span>
                        <span class="prompt">nombre</span>="Usuario con 'caracteres especiales'"
                        <span class="prompt">printf</span> "%s\n" "<span class="output">$nombre</span>"
                    </div>

                    <p><strong>Buenas pr√°cticas de seguridad:</strong></p>
                    <ul>
                        <li>Validar todas las entradas del usuario para prevenir inyecci√≥n de comandos.</li>
                        <li>Usar rutas absolutas para comandos cr√≠ticos para evitar depender de la variable <code>$PATH</code>.</li>
                        <li>Evitar el uso de <code>eval</code>, ya que puede ejecutar c√≥digo arbitrario.</li>
                        <li>Usar <code>IFS</code> para controlar c√≥mo se dividen las cadenas de texto, evitando la divisi√≥n de palabras no intencionada.</li>
                        <li>Utilizar <code>printf</code> para formatear la salida de forma segura, especialmente cuando se incluyen datos del usuario.</li>
                        <li>Ejecutar scripts con el menor privilegio posible. Evitar ejecutarlos como root a menos que sea absolutamente necesario.</li>
                        <li>Utilizar <code>set -euo pipefail</code> para detectar errores y terminar el script en caso de problemas.</li>
                    </ul>

                    <div class="exercise-box">
                        <strong><i class="fas fa-pencil-alt"></i> Ejercicios para practicar:</strong>
                        <ol>
                            <li>Crea un script que solicite al usuario un nombre de archivo y luego intente mostrar el contenido del archivo. Implementa una validaci√≥n robusta para asegurar que el nombre del archivo solo contenga caracteres alfanum√©ricos, puntos y guiones bajos. Si el nombre del archivo no es v√°lido, muestra un mensaje de error y sal del script.</li>
                            <li>Escribe un script que tome un comando como entrada del usuario y luego lo ejecute. Implementa medidas de seguridad para prevenir la inyecci√≥n de comandos. Por ejemplo, puedes permitir solo un conjunto limitado de comandos predefinidos o usar una funci√≥n que "escape" los caracteres especiales en la entrada del usuario.</li>
                            <li>Desarrolla un script que procese una lista de nombres de usuario almacenada en un archivo. Utiliza <code>IFS</code> para leer el archivo l√≠nea por l√≠nea y <code>printf</code> para mostrar cada nombre de usuario de forma segura.</li>
                            <li>Implementa un script que tome una cadena de b√∫squeda como entrada del usuario y la use para buscar archivos en un directorio. Aseg√∫rate de usar <code>find</code> de forma segura, evitando la inyecci√≥n de opciones adicionales en la b√∫squeda.</li>
                        </ol>
                    </div>
                </div>

                <div class="tech-box">
                    <div class="tech-title"><i class="fas fa-bolt"></i> Optimizaci√≥n de Scripts</div>
                    <div class="tech-image">‚ö°</div>
                    <p>
                        La eficiencia es clave en scripts avanzados. Aprender a optimizar el rendimiento mediante la paralelizaci√≥n, la minimizaci√≥n de procesos y la gesti√≥n eficiente de recursos es fundamental.
                    </p>

                    <div class="script-box">
                        <span class="comment">#!/bin/bash</span>

                        <span class="comment"># Ejemplo de paralelizaci√≥n con xargs</span>
                        <span class="prompt">echo</span> "Procesando archivos en paralelo:"
                        <span class="prompt">find</span> /ruta/a/archivos -type f -name "*.log" | <span class="prompt">xargs</span> <span class="prompt">-n</span> 1 <span class="prompt">-P</span> 4 gzip

                        <span class="comment"># Evitar bucles innecesarios</span>
                        <span class="comment"># Ineficiente:</span>
                        <span class="comment"># for archivo in $(ls /ruta/a/archivos); do ... done</span>
                        <span class="comment"># Eficiente:</span>
                        <span class="prompt">find</span> /ruta/a/archivos -type f -print0 | <span class="prompt">while</span> <span class="prompt">IFS</span>= <span class="prompt">read</span> <span class="prompt">-r</span> <span class="prompt">-d</span> $'\0' archivo; <span class="prompt">do</span>
                        <span class="output">  </span><span class="comment"># Procesar $archivo</span>
                        <span class="prompt">done</span>

                        <span class="comment"># Minimizar el uso de subshells</span>
                        <span class="comment"># Ineficiente:</span>
                        <span class="comment"># for usuario in $(cat /etc/passwd | cut -d: -f1); do ... done</span>
                        <span class="comment"># Eficiente:</span>
                        <span class="prompt">while</span> <span class="prompt">IFS</span>=: <span class="prompt">read</span> <span class="prompt">-r</span> usuario _; <span class="prompt">do</span>
                        <span class="output">  </span><span class="comment"># Procesar $usuario</span>
                        <span class="prompt">done</span> < /etc/passwd

                        <span class="comment"># Preferir comandos internos de Bash</span>
                        <span class="comment"># Ineficiente:</span>
                        <span class="comment"># var=$(echo "cadena" | wc -c)</span>
                        <span class="comment"># Eficiente:</span>
                        <span class="prompt">var</span>="${#cadena}"
                    </div>

                    <p><strong>Consejos de optimizaci√≥n:</strong></p>
                    <ul>
                        <li>Utilizar <code>xargs</code> o <code>parallel</code> para ejecutar tareas en paralelo, aprovechando m√∫ltiples n√∫cleos de la CPU.</li>
                        <li>Evitar bucles innecesarios; usar herramientas como <code>find</code> y <code>grep</code> para realizar operaciones masivas de forma eficiente.</li>
                        <li>Minimizar el uso de subshells (<code>$()</code> o ``) cuando no sean estrictamente necesarios, ya que crean un nuevo proceso.</li>
                        <li>Preferir los comandos internos de Bash sobre las herramientas externas siempre que sea posible, ya que los comandos internos son m√°s r√°pidos.</li>
                        <li>Usar la redirecci√≥n y las tuber√≠as de forma inteligente para evitar la creaci√≥n de archivos temporales.</li>
                    </ul>

                    <div class="exercise-box">
                        <strong><i class="fas fa-pencil-alt"></i> Ejercicios para practicar:</strong>
                        <ol>
                            <li>Crea un script que comprima todos los archivos de registro en un directorio, utilizando <code>xargs</code> para paralelizar el proceso de compresi√≥n. Mide el tiempo de ejecuci√≥n del script con y sin paralelizaci√≥n para comparar el rendimiento.</li>
                            <li>Escribe un script que procese un archivo de texto grande, realizando una serie de operaciones en cada l√≠nea (por ejemplo, extraer ciertos campos, realizar c√°lculos, etc.). Optimiza el script para evitar bucles innecesarios y compara el rendimiento de la versi√≥n optimizada con la versi√≥n original.</li>
                            <li>Desarrolla un script que realice una serie de operaciones en un conjunto de archivos. Utiliza subshells para realizar algunas de las operaciones y luego optimiza el script para minimizar o eliminar el uso de subshells. Compara el rendimiento de ambas versiones.</li>
                            <li>Implementa un script que realice una serie de manipulaciones de cadenas de texto. Optimiza el script para utilizar comandos internos de Bash en lugar de herramientas externas (como <code>echo</code>, <code>wc</code>, <code>cut</code>, etc.) siempre que sea posible. Mide el tiempo de ejecuci√≥n de ambas versiones para observar la mejora en el rendimiento.</li>
                        </ol>
                    </div>
                </div>
            </div>
        </section>

        <section>
            <h2><i class="fas fa-tasks"></i> Automatizaci√≥n y Programaci√≥n de Tareas</h2>

            <div class="concept-box">
                <h3><i class="fas fa-calendar-check"></i> Administrando tareas programadas</h3>
                <p>
                    La automatizaci√≥n es un pilar fundamental en la administraci√≥n de sistemas Linux. Programar tareas para que se ejecuten autom√°ticamente a intervalos regulares o en momentos espec√≠ficos permite optimizar el tiempo y asegurar la ejecuci√≥n consistente de procesos cr√≠ticos.
                </p>

                <p>
                    Los usuarios expertos de Linux no solo dominan la programaci√≥n de tareas, sino que tambi√©n comprenden las sutilezas de la gesti√≥n de entornos de ejecuci√≥n, el manejo de salidas y errores, y las estrategias para garantizar la confiabilidad y el mantenimiento de las tareas programadas.
                </p>
            </div>

            <div class="tech-container">
                <div class="tech-box">
                    <div class="tech-title"><i class="fas fa-clock"></i> cron y crontab avanzado</div>
                    <div class="tech-image">üïí</div>
                    <p>
                        Cron es el demonio de programaci√≥n de tareas est√°ndar en sistemas Linux, permitiendo la ejecuci√≥n autom√°tica de comandos y scripts a intervalos regulares.
                    </p>

                    <div class="why-learn">
                        <strong><i class="fas fa-question-circle"></i> ¬øPor qu√© deber√≠as dominarlo?</strong>
                        <p>
                            La capacidad de programar tareas con precisi√≥n y confiabilidad es esencial para la administraci√≥n eficiente de sistemas. Cron permite automatizar una amplia gama de tareas, desde copias de seguridad rutinarias hasta el monitoreo del sistema y la generaci√≥n de informes, liberando tiempo y reduciendo el riesgo de errores humanos.
                        </p>
                    </div>

                    <div class="terminal">
                        <span class="comment"># Editar el crontab del usuario actual</span>
                        <span class="prompt">$</span>
                        crontab -e

                        <span class="comment"># Formato de crontab: minuto hora d√≠a-mes mes d√≠a-semana comando</span>
                        <span class="output">
                            # Ejecutar a las 3:30 AM todos los d√≠as
                            30 3 * * * /ruta/al/script_backup.sh

                            # Ejecutar cada 15 minutos en horario laboral (Lun-Vie, 9-17)
                            */15 9-17 * * 1-5 /ruta/al/script_monitoreo.sh

                            # Ejecutar el primer d√≠a de cada mes a medianoche
                            0 0 1 * * /ruta/al/script_mensual.sh

                            # Ejecutar cada domingo a las 2 AM
                            0 2 * * 0 /ruta/al/script_semanal.sh
                        </span>

                        <span class="comment"># Ver las tareas programadas</span>
                        <span class="prompt">$</span>
                        crontab -l
                        <span class="output">[muestra las entradas del crontab]</span>

                        <span class="comment"># Ver las tareas programadas de otro usuario (como root)</span>
                        <span class="prompt">#</span>
                        crontab -u otroUsuario -l
                    </div>

                    <p><strong>Caracter√≠sticas avanzadas de cron:</strong></p>
                    <ul>
                        <li>Expresiones especiales: <code>@yearly</code>, <code>@annually</code>, <code>@monthly</code>, <code>@weekly</code>, <code>@daily</code>, <code>@midnight</code>, <code>@hourly</code>, <code>@reboot</code>.</li>
                        <li>Variables de entorno en crontab: <code>SHELL</code>, <code>PATH</code>, <code>MAILTO</code>.</li>
                        <li>Redirecci√≥n de la salida y errores de los comandos programados.</li>
                        <li>Directorios especiales: <code>/etc/cron.d/</code>, <code>/etc/cron.daily/</code>, <code>/etc/cron.hourly/</code>, <code>/etc/cron.monthly/</code>, <code>/etc/cron.weekly/</code>.</li>
                        <li>Restricciones de acceso de usuarios a cron: <code>/etc/cron.allow</code>, <code>/etc/cron.deny</code>.</li>
                        <li>Uso de <code>anacron</code> para sistemas que no est√°n encendidos las 24 horas del d√≠a.</li>
                    </ul>

                    <div class="script-box">
                        <span class="comment"># Ejemplo de crontab avanzado</span>

                        <span class="comment"># Configurar variables de entorno</span>
                        <span class="prompt">SHELL</span>=/bin/bash
                        <span class="prompt">PATH</span>=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
                        <span class="prompt">MAILTO</span>=admin@ejemplo.com

                        <span class="comment"># Redirecci√≥n de salida y errores a archivos de log</span>
                        0 2 * * * /scripts/backup_db.sh >> /var/log/backup_db.log 2>&1

                        <span class="comment"># Usar hora espec√≠fica con entorno completo</span>
                        0 5 * * * . $HOME/.profile; /scripts/informe_diario.sh

                        <span class="comment"># Ejecutar con prioridad baja usando nice</span>
                        30 3 * * * nice -n 19 /scripts/tarea_pesada.sh

                        <span class="comment"># Configurar lock para evitar ejecuciones simult√°neas</span>
                        45 * * * * flock -n /tmp/script.lock /scripts/cada_hora.sh

                        <span class="comment"># Encadenar comandos con verificaci√≥n de condiciones</span>
                        0 1 * * * [ $(date +\%d) -eq 1 ] && /scripts/primer_dia_mes.sh

                        <span class="comment"># Usar variantes de horario</span>
                        0 0 * * * [ $(date +\%u) -eq 6 ] && /scripts/fin_de_semana.sh

                        <span class="comment"># Ejecutar al iniciar el sistema</span>
                        @reboot /scripts/inicio_sistema.sh
                    </div>

                    <div class="exercise-box">
                        <strong><i class="fas fa-pencil-alt"></i> Ejercicios para practicar:</strong>
                        <ol>
                            <li>Configura una tarea cron que realice una copia de seguridad de tus documentos cada viernes a las 18:00 y env√≠e un correo electr√≥nico de notificaci√≥n al administrador.</li>
                            <li>Crea un crontab que ejecute diferentes scripts seg√∫n el d√≠a de la semana: un script para mantenimiento diario, otro para an√°lisis semanal y un tercero para limpieza mensual.</li>
                            <li>Implementa un sistema de rotaci√≥n de logs para un script ejecutado por cron, utilizando la herramienta <code>logrotate</code> para gestionar los archivos de registro.</li>
                            <li>Configura un script para ser ejecutado por cron que verifique primero si otra instancia del mismo script ya est√° en ejecuci√≥n y, de ser as√≠, termine su propia ejecuci√≥n para evitar conflictos.</li>
                        </ol>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="footer-bar">
            <button onclick="window.location.href='03_avanzado.html'">
                ‚¨Ö Nivel Anterior
            </button>
            <button onclick="window.location.href='index.html'">
                Volver al √çndice
            </button>
        </div>
    </footer>
</body>
</html>